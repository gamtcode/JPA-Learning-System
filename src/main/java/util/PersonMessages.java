package util;

public class PersonMessages {

    public static final String PERSIST_MSG = "\nThe 'persist' method accepts an entity instance as a parameter and makes this instance managed and persistent. This means that the entity instance is stored in the persistence context and will be saved to the database the next time the context is flushed (usually during transaction commit). If the entity is already a managed entity, the behavior of the 'persist' method is ignored. If the entity is a detached entity, an application should call 'merge' instead of 'persist'. The method begins a transaction, attempts to persist the entity, and then commits the transaction. If an exception occurs during any of these steps, the method checks if the transaction is still active and, if so, rolls back the transaction. The exception can occur in various situations such as when the entity is not a valid entity, is a removed entity, the transaction cannot be started, the entity cannot be persisted, or the transaction cannot be committed. The exception's error message is then printed to the error console. Therefore, it is important that the entity passed to this method is in a state that can be persisted and that the persistence environment is in a state that allows the initiation, persistence, and commitment of transactions.";

    public static final String MERGE_MSG = "\nThe 'merge' method accepts a detached entity instance as a parameter and merges the changes of this instance back into the persistence context. This means that the state of the entity instance is copied over to a managed entity with the same ID. If there is no managed entity with the same ID, one will be created. If the entity is already a managed entity, the behavior of the 'merge' method is ignored. If the entity is a new entity, an application should call 'persist' instead of 'merge'. The method begins a transaction, attempts to merge the entity, and then commits the transaction. If an exception occurs during any of these steps, the method checks if the transaction is still active and, if so, rolls back the transaction. The exception can occur in various situations such as when the entity is not a valid entity, is a removed entity, the transaction cannot be started, the entity cannot be merged, or the transaction cannot be committed. The exception's error message is then printed to the error console. Therefore, it is important that the entity passed to this method is in a state that can be merged and that the persistence environment is in a state that allows the initiation, merging, and commitment of transactions.";

    public static final String REMOVE_MSG = "\nThe 'remove' method accepts an entity instance as a parameter and removes this instance from the persistence context, causing the entity to be removed from the database. This means that the entity instance will no longer be managed and its state will not be synchronized with the database. If the entity is already a detached entity, the behavior of the 'remove' method is ignored. If the entity is a new entity, an application should not call 'remove'. The method begins a transaction, attempts to remove the entity, and then commits the transaction. If an exception occurs during any of these steps, the method checks if the transaction is still active and, if so, rolls back the transaction. The exception can occur in various situations such as when the entity is not a valid entity, is a new entity, the transaction cannot be started, the entity cannot be removed, or the transaction cannot be committed. The exception's error message is then printed to the error console. Therefore, it is important that the entity passed to this method is in a state that can be removed and that the persistence environment is in a state that allows the initiation, removal, and commitment of transactions.";

    public static final String FIND_MSG = "\nThe 'find' method accepts a primary key as a parameter and attempts to find an entity of type 'Person' with this primary key in the persistence context. If the entity is found, it is returned; if not, null is returned. This means that the method can be used to check whether an entity with a certain primary key exists in the database. The method does not start or commit a transaction, as it is a read-only operation. If an IllegalArgumentException occurs during the operation, such as when the provided primary key is not a valid type for the 'Person' entity, the exception's error message is printed to the error console and the method returns null. Therefore, it is important that the primary key passed to this method is of a valid type for the 'Person' entity.";

    public static final String GET_REFERENCE_MSG = "\nThe 'getReference' method accepts a primary key as a parameter and attempts to get a reference to the entity of type 'Person' with this primary key in the persistence context. This method enables lazy loading, meaning that the entity's data is not retrieved until it is actually needed. This can be beneficial for performance when dealing with large entities. If the entity is found, a reference to it is returned; if not, an EntityNotFoundException is thrown. The method does not start or commit a transaction, as it is a read-only operation. If an EntityNotFoundException occurs during the operation, such as when there is no entity of type 'Person' with the provided primary key in the database, the exception's error message is printed to the error console and the method returns null. Therefore, it is important that the primary key passed to this method is of a valid type for the 'Person' entity and that an entity with this primary key exists in the database.";

    public static final String FLUSH_MSG = "\nThe 'flush' method synchronizes the persistence context with the underlying database. This means that any changes made to managed entities in the persistence context are written to the database. This operation is typically performed before a query is executed to ensure that the query operates on the most recent state of the entities. The method does not start or commit a transaction, as it is not necessary for a flush operation. If a PersistenceException occurs during the operation, such as when the changes cannot be written to the database due to a constraint violation or other database error, the exception's error message is printed to the error console. Therefore, it is important that the state of the entities in the persistence context is valid for the database schema and that the database is in a state that allows changes to be written. \n\nThe flush() method in JPA is used to immediately synchronize the current state of the persistence context (memory) with the database. While it's true that any changes to a managed entity are automatically synchronized with the database, this typically happens at the end of the current transaction, when the transaction is committed. This is called \"automatic flush\". However, there may be situations where you want to synchronize changes immediately, before the end of the transaction. For example, you might want to ensure an entity is immediately inserted into the database to generate a database ID, or you might want to run a query that reflects the latest changes made to managed entities. In these cases, you can use the flush() method to force a \"manual flush\". This will immediately synchronize the persistence context with the database, regardless of the state of the current transaction. Remember that calling flush() can be expensive in terms of performance, as it may result in immediate database operations. Therefore, it's best to use flush() sparingly and only when necessary.";

    public static final String IS_ACTIVE_MSG = "\nThe 'isActive' method checks if the current transaction associated with the EntityManager is active. This is a read-only operation and does not start, commit, or rollback a transaction. If an IllegalStateException occurs during the operation, such as when the EntityManager is in a state that does not allow a transaction to be retrieved (for example, if the EntityManager is closed), the exception's error message is printed to the error console. Therefore, it is important that the EntityManager is in a state that allows a transaction to be retrieved when this method is called.";

    public static final String CLEAR_MSG = "\nThe 'clear' method clears the persistence context, detaching all entities. This means that all entities that were previously managed become detached and their state will not be synchronized with the database. This operation is typically performed when you want to free up memory in a long-running application or when you want to avoid any automatic synchronization between the persistence context and the database. The method does not start or commit a transaction, as it is not necessary for a clear operation. If an IllegalStateException occurs during the operation, such as when the EntityManager is in a state that does not allow the persistence context to be cleared (for example, if the EntityManager is closed), the exception's error message is printed to the error console. Therefore, it is important that the EntityManager is in a state that allows the persistence context to be cleared when this method is called.";

    public static final String DETACH_MSG = "\nThe 'detach' method accepts an entity instance as a parameter and detaches this instance from the persistence context. This means that the entity instance will no longer be managed and its state will not be synchronized with the database. This operation is typically performed when you want to work with an entity without affecting its state in the database. The method does not start or commit a transaction, as it is not necessary for a detach operation. If an IllegalArgumentException occurs during the operation, such as when the provided entity is null or is not a managed entity, the exception's error message is printed to the error console. Therefore, it is important that the entity passed to this method is a managed entity and is not null.";

    public static final String IS_ENTITY_MANAGER_OPEN_MSG = "\nThe 'isOpen' method checks if the EntityManager is open. This means that the EntityManager is in a state where it can be used to perform operations on entities. If the EntityManager is open, the method returns true; if not, it returns false. This operation is typically performed before attempting to perform operations on the EntityManager to ensure that it is in a valid state. The method does not start or commit a transaction, as it is a read-only operation. Therefore, it can be used at any time to check the state of the EntityManager.";

    public static final String GET_METAMODEL_MSG = "\nThe 'getMetamodel' method retrieves the Metamodel instance that corresponds to the persistence context. The Metamodel interface is the entry point to the metamodel API, which allows for typesafe querying of entities. It provides access to the managed classes of the persistence unit, including entities, embeddables, and managed types. The method does not start or commit a transaction, as it is a read-only operation. If an IllegalStateException occurs during the operation, such as when the EntityManager is in a state that does not allow the metamodel to be retrieved (for example, if the EntityManager is closed), the exception's error message is printed to the error console and the method returns null. Therefore, it is important that the EntityManager is in a state that allows the metamodel to be retrieved when this method is called.";

    public static final String CREATE_QUERY_MSG = "\nThe 'createQuery' method accepts a JPQL (Java Persistence Query Language) query string as a parameter and creates a new Query instance for this JPQL query. This Query instance can be used to control and execute the query. The method does not start or commit a transaction, as it is not necessary for a query creation operation. If an IllegalArgumentException occurs during the operation, such as when the provided JPQL query string is not a valid JPQL query, the exception's error message is printed to the error console and the method returns null. Therefore, it is important that the JPQL query string passed to this method is a valid JPQL query.";

    public static final String CREATE_NAMED_QUERY_MSG = "\nThe 'createNamedQuery' method accepts a name as a parameter and creates a new Query instance for the named query. Named queries are queries that have been defined in metadata, typically using the @NamedQuery annotation in the entity class. This allows for the reuse of queries and can improve performance as the query does not need to be parsed every time it is executed. The method does not start or commit a transaction, as it is not necessary for a query creation operation. If an IllegalArgumentException occurs during the operation, such as when the provided name does not correspond to a named query in the metadata, the exception's error message is printed to the error console and the method returns null. Therefore, it is important that the name passed to this method corresponds to a named query in the metadata.";

    public static final String CREATE_NATIVE_QUERY_MSG = "\nThe 'createNativeQuery' method accepts a native SQL query string as a parameter and creates a new Query instance for this SQL query. This allows for the execution of native SQL queries, which can be useful when you need to use database-specific features that are not supported by JPQL. The method does not start or commit a transaction, as it is not necessary for a query creation operation. If an IllegalArgumentException occurs during the operation, such as when the provided SQL query string is not a valid SQL query, the exception's error message is printed to the error console and the method returns null. Therefore, it is important that the SQL query string passed to this method is a valid SQL query.";

    public static final String CREATE_NATIVE_QUERY_WITH_CLASS_MSG = "\nThe 'createNativeQuery' method accepts a native SQL query string and a result class as parameters and creates a new Query instance for this SQL query. The result class parameter specifies the type of the query result. This allows for the execution of native SQL queries and the mapping of the query result to a specific class, which can be useful when you need to use database-specific features that are not supported by JPQL and when you want to map the result to a specific class. The method does not start or commit a transaction, as it is not necessary for a query creation operation. If an IllegalArgumentException occurs during the operation, such as when the provided SQL query string is not a valid SQL query or when the provided result class is not a valid class for the query result, the exception's error message is printed to the error console and the method returns null. Therefore, it is important that the SQL query string and the result class passed to this method are valid.";

    public static final String CREATE_NATIVE_QUERY_WITH_MAPPING_MSG = "\nThe 'createNativeQuery' method accepts a native SQL query string and a result set mapping as parameters and creates a new Query instance for this SQL query. The result set mapping parameter specifies the mapping of the query result to entity classes and/or scalar values. This allows for the execution of native SQL queries and the mapping of the query result according to a specific result set mapping, which can be useful when you need to use database-specific features that are not supported by JPQL and when you want to map the result to specific entity classes and/or scalar values. The method does not start or commit a transaction, as it is not necessary for a query creation operation. If an IllegalArgumentException occurs during the operation, such as when the provided SQL query string is not a valid SQL query or when the provided result set mapping does not correspond to a result set mapping in the metadata, the exception's error message is printed to the error console and the method returns null. Therefore, it is important that the SQL query string and the result set mapping passed to this method are valid.";

    public static final String LOCK_MSG = "\nThe 'lock' method accepts an entity instance and a LockModeType as parameters and locks the entity with the provided lock type. Locking an entity can be used to prevent concurrent access to the entity's state in a multi-user or multi-threaded environment. The LockModeType parameter specifies the type of the lock. While there are several types of locks, such as OPTIMISTIC, OPTIMISTIC_FORCE_INCREMENT, PESSIMISTIC_READ, PESSIMISTIC_WRITE, and PESSIMISTIC_FORCE_INCREMENT, in this case, we are illustrating only with the OPTIMISTIC and PESSIMISTIC_WRITE options. The method does not start or commit a transaction, but it is typically used within a transaction. If an exception occurs during the operation, such as when the provided entity is not a managed entity, when the lock mode is not one of the allowed types, or when the lock cannot be obtained, the exception's error message is printed to the error console. Therefore, it is important that the entity passed to this method is a managed entity and that the lock mode is one of the allowed types.";

    public static final String REFRESH_MSG = "\nThe 'refresh' method accepts an entity instance as a parameter and refreshes the state of the entity with the current state in the database. This can be useful when you want to discard all changes made to the entity and revert to the current state in the database. The method now starts and commits a transaction for each entity it refreshes. If an exception occurs during the operation, such as when the provided entity is not a managed entity or when the state of the entity cannot be refreshed, the transaction is rolled back and a custom error message is printed to the error console. Therefore, it is important that the entity passed to this method is a managed entity.";

    public static final String CONTAINS_MSG = "\nThe 'contains' method accepts an entity instance as a parameter and checks if the entity is managed by the EntityManager. An entity is managed if it is currently being tracked by the EntityManager, which means that any changes made to the entity will be persisted to the database when the transaction is committed. The method returns true if the entity is managed, and false otherwise. The method does not start or commit a transaction, as it is a read-only operation. If an IllegalArgumentException occurs during the operation, such as when the provided entity is not a valid entity, the exception's error message is printed to the error console and the method returns false. Therefore, it is important that the entity passed to this method is a valid entity.";

    public static final String CLOSE_ENTITY_MANAGER_MSG = "\nThe 'close' method closes the EntityManager, releasing its resources. This is typically done when you are done using the EntityManager and want to free up the resources it is using. Once an EntityManager has been closed, it is no longer usable. If an IllegalStateException occurs during the operation, such as when the EntityManager is already closed, the exception's error message is printed to the error console. Therefore, it is important to ensure that the EntityManager is not already closed before calling this method.";

    public static final String PERSON_NOT_FOUND_MSG = "\nThe person with the entered ID does not exist in the database.";

}